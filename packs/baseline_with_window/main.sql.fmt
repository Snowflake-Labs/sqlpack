-- ---
-- params:
-- - name: base_table
-- - name: warehouse
-- - name: lookback_time_in_days
--   default: 90
-- - name: time_column
-- - name: groupby_columns
-- varmap:
--   target_table: '{base_table}_counts'
--   task_name: '{base_table}_count_window'

CREATE OR REPLACE TABLE {target_table} (
    slice_start timestamp_ltz,
    slice_end timestamp_ltz,
    groups variant,
    n number
);


CREATE FUNCTION IF NOT EXISTS time_slices (
    n NUMBER, 
    s TIMESTAMP_NTZ, 
    e TIMESTAMP_NTZ
)
RETURNS TABLE (
    slice_start TIMESTAMP_NTZ,
    slice_end TIMESTAMP_NTZ
)
AS 
$$
SELECT
  DATEADD(
      sec,
      DATEDIFF(sec, s, e) * ROW_NUMBER() OVER (
        ORDER BY SEQ4()
    ) / n,
    s
  ) AS slice_start,
  DATEADD(sec, DATEDIFF(sec, s, e) * 1 / n, slice_start) AS slice_end
FROM
    TABLE(GENERATOR(ROWCOUNT => n)) 
$$;


CREATE FUNCTION IF NOT EXISTS time_slices (
    n NUMBER, 
    s TIMESTAMP_LTZ, 
    e TIMESTAMP_LTZ
)
RETURNS TABLE (
    slice_start TIMESTAMP_LTZ,
    slice_end TIMESTAMP_LTZ
)
AS 
$$
SELECT
  DATEADD(
    sec,
    DATEDIFF(sec, s, e) * ROW_NUMBER() OVER (
      ORDER BY SEQ4()
    ) / n,
    s
  ) AS slice_start,
  DATEADD(sec, DATEDIFF(sec, s, e) * 1 / n, slice_start) AS slice_end
FROM 
    TABLE(GENERATOR(ROWCOUNT => n))
$$;


CREATE FUNCTION IF NOT EXISTS time_slices_before_t (
    num_slices NUMBER,
    seconds_in_slice NUMBER,
    t TIMESTAMP_NTZ
) 
RETURNS TABLE (
    slice_start TIMESTAMP_NTZ,
    slice_end TIMESTAMP_NTZ
)
AS 
$$
SELECT
  slice_start,
  slice_end
FROM TABLE(
    time_slices(
        num_slices,
        DATEADD(sec, - seconds_in_slice * num_slices, t),
      t
    )
  )
$$;


CREATE FUNCTION IF NOT EXISTS time_slices_before_t (
    num_slices NUMBER,
    seconds_in_slice NUMBER,
    t TIMESTAMP_LTZ
)
RETURNS TABLE (
    slice_start TIMESTAMP_LTZ,
    slice_end TIMESTAMP_LTZ
)
AS 
$$
SELECT
  slice_start,
  slice_end
FROM TABLE
(
    time_slices (
      num_slices,
      DATEADD(sec, - seconds_in_slice * num_slices, t),
      t
    )
  )
$$;
    
    
CREATE OR REPLACE TASK {task_name} 
SCHEDULE = 'USING CRON 0 * * * * UTC' 
WAREHOUSE = {warehouse} 
AS 
MERGE INTO {target_table} stored USING (
    -- calculate sums
    SELECT
        COUNT(*) n,
        slice_start,
        slice_end,
        groups
    FROM
        (
            -- make the slices
            SELECT
                slice_start,
                slice_end
            FROM
                TABLE (
                    TIME_SLICES_BEFORE_T (
                        {lookback_time_in_days} * 24,
                        60 * 60,
                        DATE_TRUNC(HOUR, CURRENT_TIMESTAMP())
                    )
                )
        ) t
        JOIN (
            -- calculate sums in those slices
            SELECT
                {time_column} event_time,
                OBJECT_CONSTRUCT({groupby_columns}) AS groups
            FROM
                {base_table}
        ) c ON c.event_time BETWEEN t.slice_start
        AND t.slice_end
    GROUP BY
        slice_start,
        slice_end,
        groups
) calcd ON (
    stored.groups = calcd.groups
    AND stored.slice_start = calcd.slice_start
    AND stored.slice_end = calcd.slice_end
)
WHEN NOT MATCHED THEN
INSERT (
    slice_start,
    slice_end,
    groups, 
    n
)
VALUES (
    slice_start,
    slice_end,
    groups,
    n
);
    
    
ALTER TASK {task_name} RESUME;


--BASIC_BASELINE_VIEW_WITH_WINDOW
CREATE OR REPLACE VIEW {base_table}_pct_baseline_window AS
SELECT
    *
FROM
    (
        SELECT
            slice_start hour,
            groups,
            n,
            APPROX_PERCENTILE_ESTIMATE(pct,.01) pct01,
            APPROX_PERCENTILE_ESTIMATE(pct,.05) pct05,
            APPROX_PERCENTILE_ESTIMATE(pct,.10) pct10,
            APPROX_PERCENTILE_ESTIMATE(pct,.50) pct50,
            APPROX_PERCENTILE_ESTIMATE(pct,.90) pct90,
            APPROX_PERCENTILE_ESTIMATE(pct,.95) pct95,
            APPROX_PERCENTILE_ESTIMATE(pct,.99) pct99
        FROM
            (
                SELECT
                    SUM(n) OVER (
                        PARTITION BY groups
                        ORDER BY
                            slice_start ROWS BETWEEN 24 PRECEDING
                            AND 1 PRECEDING
                    ) n,
                    APPROX_PERCENTILE_ACCUMULATE(n) OVER (PARTITION BY GROUPS) pct,
                    slice_start,
                    groups
                FROM
                    (
                        -- zero-filled count table
                        SELECT
                            ZEROIFNULL(n) n,
                            groups,
                            slice_start,
                            slice_end
                        FROM
                            {target_table}
                            RIGHT JOIN (
                                -- zero filled matrix of (groups X slices)
                                SELECT
                                    groups,
                                    slice_start,
                                    slice_end
                                FROM
                                    (
                                        SELECT
                                            DISTINCT groups
                                        FROM
                                            {target_table}
                                    ) g
                                    CROSS JOIN (
                                        SELECT
                                            slice_start,
                                            slice_end
                                        FROM
                                            TABLE(
                                                TIME_SLICES_BEFORE_T(
                                                    90 * 24,
                                                    60 * 60,
                                                    DATE_TRUNC(HOUR, CURRENT_TIMESTAMP())
                                                )
                                            )
                                    ) t
                                WHERE
                                    slice_start > DATEADD(
                                        HOUR,
                                        -24 * (90 + 1),
                                        DATE_TRUNC(HOUR, CURRENT_TIMESTAMP())
                                    )
                            ) USING (groups, slice_start, slice_end)
                    )
            )
        WHERE
            slice_start > DATEADD(
                HOUR,
                -24 * 90,
                DATE_TRUNC(HOUR, CURRENT_TIMESTAMP())
            )
    )
WHERE
    hour = (
        SELECT
            MAX(slice_start)
        FROM
            {target_table}
    )
ORDER BY
    n DESC;
