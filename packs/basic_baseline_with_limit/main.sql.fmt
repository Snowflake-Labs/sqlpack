-- ---
-- params:
-- - name: base_table
-- - name: warehouse
-- - name: lookback_time_in_days
--   default: 90
-- - name: time_column
-- - name: limit
-- - name: groupby_columns
-- varmap:
--   target_table: '{base_table}_counts'
--   task_name: '{base_table}_count'


CREATE OR REPLACE TABLE {target_table} (
    slice_start timestamp_ltz,
    slice_end timestamp_ltz,
    groups variant,
    n number
);


CREATE FUNCTION IF NOT EXISTS time_slices (
    n NUMBER, 
    s TIMESTAMP_NTZ, 
    e TIMESTAMP_NTZ
)
RETURNS TABLE (
    slice_start TIMESTAMP_NTZ,
    slice_end TIMESTAMP_NTZ
)
AS 
$$
SELECT
  DATEADD(
      sec,
      DATEDIFF(sec, s, e) * ROW_NUMBER() OVER (
        ORDER BY SEQ4()
    ) / n,
    s
  ) AS slice_start,
  DATEADD(sec, DATEDIFF(sec, s, e) * 1 / n, slice_start) AS slice_end
FROM
    TABLE(GENERATOR(ROWCOUNT => n)) 
$$;


CREATE FUNCTION IF NOT EXISTS time_slices (
    n NUMBER, 
    s TIMESTAMP_LTZ, 
    e TIMESTAMP_LTZ
)
RETURNS TABLE (
    slice_start TIMESTAMP_LTZ,
    slice_end TIMESTAMP_LTZ
)
AS 
$$
SELECT
  DATEADD(
    sec,
    DATEDIFF(sec, s, e) * ROW_NUMBER() OVER (
      ORDER BY SEQ4()
    ) / n,
    s
  ) AS slice_start,
  DATEADD(sec, DATEDIFF(sec, s, e) * 1 / n, slice_start) AS slice_end
FROM 
    TABLE(GENERATOR(ROWCOUNT => n))
$$;


CREATE FUNCTION IF NOT EXISTS time_slices_before_t (
    num_slices NUMBER,
    seconds_in_slice NUMBER,
    t TIMESTAMP_NTZ
) 
RETURNS TABLE (
    slice_start TIMESTAMP_NTZ,
    slice_end TIMESTAMP_NTZ
)
AS 
$$
SELECT
  slice_start,
  slice_end
FROM TABLE(
    time_slices(
        num_slices,
        DATEADD(sec, - seconds_in_slice * num_slices, t),
      t
    )
  )
$$;


CREATE FUNCTION IF NOT EXISTS time_slices_before_t (
    num_slices NUMBER,
    seconds_in_slice NUMBER,
    t TIMESTAMP_LTZ
)
RETURNS TABLE (
    slice_start TIMESTAMP_LTZ,
    slice_end TIMESTAMP_LTZ
)
AS 
$$
SELECT
  slice_start,
  slice_end
FROM TABLE
(
    time_slices (
      num_slices,
      DATEADD(sec, - seconds_in_slice * num_slices, t),
      t
    )
  )
$$;
    
    
CREATE OR REPLACE TASK {task_name} 
SCHEDULE = 'USING CRON 0 * * * * UTC' 
WAREHOUSE = {warehouse} 
AS 
MERGE INTO {target_table} stored USING (
    -- calculate sums
    SELECT
        COUNT(*) n,
        slice_start,
        slice_end,
        groups
    FROM
        (
            -- make the slices
            SELECT
                slice_start,
                slice_end
            FROM
                TABLE (
                    TIME_SLICES_BEFORE_T (
                        {lookback_time_in_days} * 24,
                        60 * 60,
                        DATE_TRUNC(HOUR, CURRENT_TIMESTAMP())
                    )
                )
        ) t
        JOIN (
            -- calculate sums in those slices
            SELECT
                {time_column} event_time,
                OBJECT_CONSTRUCT({groupby_columns}) AS groups
            FROM
                {base_table}
        ) c ON c.event_time BETWEEN t.slice_start
        AND t.slice_end
    GROUP BY
        slice_start,
        slice_end,
        groups
) calcd ON (
    stored.groups = calcd.groups
    AND stored.slice_start = calcd.slice_start
    AND stored.slice_end = calcd.slice_end
)
WHEN NOT MATCHED THEN
INSERT (
    slice_start,
    slice_end,
    groups, 
    n
)
VALUES (
    slice_start,
    slice_end,
    groups,
    n
);
    
    
ALTER TASK {task_name} RESUME;
    
-- BASIC_BASELINE_VIEW
CREATE OR REPLACE VIEW {base_table}_pct_baseline 
AS
SELECT
    *
FROM
    (
        SELECT
            slice_start hour,
            groups,
            n,
            APPROX_PERCENTILE(n,.01) OVER (PARTITION BY groups) pct01,
            APPROX_PERCENTILE(n,.05) OVER (PARTITION BY groups) pct05,
            APPROX_PERCENTILE(n,.10) OVER (PARTITION BY groups) pct10,
            APPROX_PERCENTILE(n,.50) OVER (PARTITION BY groups) pct50,
            APPROX_PERCENTILE(n,.90) OVER (PARTITION BY groups) pct90,
            APPROX_PERCENTILE(n,.95) OVER (PARTITION BY groups) pct95,
            APPROX_PERCENTILE(n,.99) OVER (PARTITION BY groups) pct99
        FROM
            (
                -- zero-filled count table
                SELECT
                    ZEROIFNULL(n) n,
                    groups,
                    slice_start,
                    slice_end
                FROM
                    {target_table}
                    RIGHT JOIN (
                        -- zero filled matrix of (groups X slices)
                        SELECT
                            groups,
                            slice_start,
                            slice_end
                        FROM
                            (
                                SELECT
                                    DISTINCT groups
                                FROM
                                    {target_table}
                            ) g
                            CROSS JOIN (
                                SELECT
                                    slice_start,
                                    slice_end
                                FROM
                                    TABLE (
                                        TIME_SLICES_BEFORE_T (
                                            {lookback_time_in_days} * 24,
                                            60 * 60,
                                            DATE_TRUNC(HOUR, CURRENT_TIMESTAMP)
                                        )
                                    )
                            ) t
                    ) USING (groups, slice_start, slice_end)
                ORDER BY
                    n DESC
                LIMIT {limit}
            )
        WHERE
            slice_start > DATEADD(
                HOUR,
                -24 * {lookback_time_in_days},
                DATE_TRUNC(HOUR, CURRENT_TIMESTAMP)
            )
    )
WHERE
    hour = (
        SELECT
            MAX(slice_start)
        FROM
            {target_table}
    )
ORDER BY
    n DESC
;
