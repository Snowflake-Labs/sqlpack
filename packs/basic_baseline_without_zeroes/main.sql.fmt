-- ---
-- params:
-- - name: base_table
-- - name: warehouse
-- - name: days
--   default: 90
-- - name: time_column
-- varmap:
--   target_table: '{base_table}_counts'
--   task_name: '{base_table}_count'

CREATE OR REPLACE TABLE {target_table} (
    slice_start timestamp_ltz,
    slice_end timestamp_ltz,
    groups variant,
    n number
);


CREATE FUNCTION IF NOT EXISTS time_slices (
    n NUMBER, s TIMESTAMP_NTZ,
    e TIMESTAMP_NTZ
) 
RETURNS TABLE (
    slice_start TIMESTAMP_NTZ,
    lice_end TIMESTAMP_NTZ
    ) 
AS 
$$
SELECT
  DATEADD(
      sec,
      DATEDIFF(sec, s, e) * ROW_NUMBER() OVER (
        ORDER BY SEQ4()
    ) / n,
    s
  ) AS slice_start,
  DATEADD(sec, DATEDIFF(sec, s, e) * 1 / n, slice_start) AS slice_end
FROM
  TABLE(GENERATOR(ROWCOUNT => n))
$$ ;


CREATE FUNCTION IF NOT EXISTS time_slices (
    n NUMBER, s TIMESTAMP_LTZ,
    e TIMESTAMP_LTZ
) 
RETURNS TABLE (
    slice_start TIMESTAMP_LTZ,
    slice_end TIMESTAMP_LTZ
) 
AS 
$$
SELECT
  DATEADD(
    sec,
    DATEDIFF(sec, s, e) * ROW_NUMBER() OVER (
      ORDER BY SEQ4()
    ) / n,
    s
  ) AS slice_start,
  DATEADD(sec, DATEDIFF(sec, s, e) * 1 / n, slice_start) AS slice_end
FROM TABLE(GENERATOR(ROWCOUNT => n))
$$ ;


CREATE FUNCTION IF NOT EXISTS time_slices_before_t (
    num_slices NUMBER, 
    seconds_in_slice NUMBER, 
    t TIMESTAMP_NTZ
) 
RETURNS TABLE (
    slice_start TIMESTAMP_NTZ,
    slice_end TIMESTAMP_NTZ
) 
AS 
$$
SELECT
  slice_start,
  slice_end
FROM TABLE(
    time_slices(
        num_slices,
        DATEADD(sec, - seconds_in_slice * num_slices, t),
      t
    )
  )
$$ ;


CREATE FUNCTION IF NOT EXISTS time_slices_before_t (
    num_slices NUMBER, 
    seconds_in_slice NUMBER, 
    t TIMESTAMP_LTZ
) 
RETURNS TABLE (
    slice_start TIMESTAMP_LTZ,
    slice_end TIMESTAMP_LTZ
) 
AS 
$$
SELECT
  slice_start,
  slice_end
FROM
  TABLE(
    time_slices (
      num_slices,
      DATEADD(sec, - seconds_in_slice * num_slices, t),
      t
    )
  )
$$ ;


CREATE OR REPLACE TASK {task_name} 
SCHEDULE = 'USING CRON 0 * * * * UTC' 
WAREHOUSE = {warehouse} AS
MERGE INTO {target_table} stored USING (
    -- calculate sums
    SELECT COUNT(*) n,
        slice_start,
        slice_end,
        groups
    FROM (-- make the slices
        SELECT 
            slice_start,
            slice_end
            FROM TABLE (
                TIME_SLICES_BEFORE_T (
                    {days} * 24, 60 * 60, 
                    DATE_TRUNC(HOUR, CURRENT_TIMESTAMP())
                )
            )
    ) t
    JOIN (
        -- calculate sums in those slices
        SELECT 
            {time_column} event_time,
            OBJECT_CONSTRUCT(
                'city',city, 
                'users',user
            ) AS groups
        FROM 
            {base_table}) c 
        ON 
            c.event_time BETWEEN t.slice_start AND t.slice_end
        GROUP BY 
            slice_start,
            slice_end,
            groups
    ) calcd 
ON (
    stored.groups = calcd.groups
    AND stored.slice_start = calcd.slice_start
    AND stored.slice_end = calcd.slice_end
) 
WHEN NOT MATCHED THEN
INSERT (
    slice_start,
    slice_end,
    groups,
    n
)
VALUES (
    slice_start,
    slice_end,
    groups,
    n
);


ALTER TASK {task_name} RESUME;

--BASIC_BASELINE_VIEW_NO_ZEROS
CREATE OR REPLACE VIEW {base_table}_pct_baseline_wo_zeroes COPY GRANTS AS
SELECT *
FROM ( 
    SELECT 
        slice ,
        groups ,
        n ,
        APPROX_PERCENTILE_ESTIMATE(pct, .01) pct01 ,
        APPROX_PERCENTILE_ESTIMATE(pct, .05) pct05 ,
        APPROX_PERCENTILE_ESTIMATE(pct, .10) pct10 ,
        APPROX_PERCENTILE_ESTIMATE(pct, .50) pct50 ,
        APPROX_PERCENTILE_ESTIMATE(pct, .90) pct90 ,
        APPROX_PERCENTILE_ESTIMATE(pct, .95) pct95 ,
        APPROX_PERCENTILE_ESTIMATE(pct, .99) pct99
    FROM( 
        SELECT 
            slice_start slice ,
            current_hour ,
            ZEROIFNULL(n) n ,
            groups ,
            pct
            FROM {base_table}_counts
                RIGHT OUTER JOIN( 
                    SELECT 
                        groups ,
                        DATE_TRUNC(HOUR, CURRENT_TIMESTAMP()) current_hour ,
                        APPROX_PERCENTILE_ACCUMULATE(n) 
                        OVER (
                            PARTITION BY GROUPS
                        ) pct
                    FROM 
                        {base_table}_counts
                    WHERE 
                        slice_start BETWEEN DATEADD(HOUR, -24 * {days} - 1, current_hour) 
                        AND DATEADD(HOUR, -1, current_hour) 
                ) 
            USING (groups)
            WHERE slice = current_hour 
        )
    )



